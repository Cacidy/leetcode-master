<!--
 * @Author: Cao Yuwei 108244861+Cacidy@users.noreply.github.com
 * @Date: 2025-03-22 21:21:14
 * @LastEditors: Cao Yuwei 108244861+Cacidy@users.noreply.github.com
 * @LastEditTime: 2025-03-23 10:42:45
 * @FilePath: /leetcode-master/ownnotes/动态规划笔记.md
 * @Description: 这是默认设置,请设置`customMade`, 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
-->
# 动态规划（Dynamic Programming）

动态规划，英文：Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。  
所以动态规划中每一个状态一定是由上一个状态推导出来的  
对于动态规划问题，我将拆解为如下五步曲，这五步都搞清楚了，才能说把动态规划真的掌握了！  

确定dp数组（dp table）以及下标的含义  
确定递推公式  
dp数组如何初始化  
确定遍历顺序  
举例推导dp数组  
一些同学可能想为什么要先确定递推公式，然后在考虑初始化呢？  

因为一些情况是递推公式决定了dp数组要如何初始化！  

---

## 🧠 核心思想

- **最优子结构（Optimal Substructure）**：一个问题的最优解可以由其子问题的最优解构成。
- **重叠子问题（Overlapping Subproblems）**：子问题之间重复出现。
- **状态转移（State Transition）**：从已知的子问题推出较大的问题的解。
- **记忆化搜索 / 自底向上**：用数组或哈希表存储子问题结果，避免重复计算。

---

## 🧱 一般解题步骤

1. **确定子问题的定义（状态）**
   - 通常用 `dp[i]` 表示前 `i` 个元素/长度为 `i` 时的最优解。
2. **写出状态转移方程（递推公式）**
   - 例如：`dp[i] = max(dp[i-1], dp[i-2] + nums[i])`
3. **初始化（base case）**
   - 例如：`dp[0] = 0`, `dp[1] = nums[0]`
4. **确定遍历顺序**
   - 通常是从小到大（自底向上），也有倒序的（如背包问题优化）
5. **返回结果**
   - 最后一个状态或所有状态中的最优值

---

## 🧮 常见动态规划类型

| 类型           | 特征                                     | 例题                         |
|----------------|------------------------------------------|------------------------------|
| 1D DP          | 一维数组求最优解                         | 打家劫舍、爬楼梯              |
| 2D DP          | 二维表格问题（如区间、网格）             | 最长公共子序列、最小路径和    |
| 背包问题        | 每个物品只能用一次 or 无限次             | 0-1 背包、完全背包            |
| 子序列/子串     | 比较两个字符串之间的匹配关系             | 编辑距离、最长递增子序列      |
| 区间DP         | 区间切割或合并问题                       | 戳气球、石子合并              |
| 数位DP         | 处理与数字位数相关的问题                 | 各种计数问题                  |
| 状压DP         | 使用二进制压缩状态                       | 旅行商问题、集合划分          |
| 树形DP         | 图的结构是树                             | 树的最长路径、树上独立集      |
| 记忆化搜索     | DFS + 缓存中间结果                       | 青蛙跳台阶、剪绳子            |

---

## 📚 经典例题

### 1. 爬楼梯（Climbing Stairs）

```python
def climbStairs(n: int) -> int:
    if n <= 2:
        return n
    dp = [0] * (n + 1)
    dp[1], dp[2] = 1, 2
    for i in range(3, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]
    return dp[n]
```  
